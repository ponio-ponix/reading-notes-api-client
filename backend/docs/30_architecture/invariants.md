# Invariants (不変条件) – Notes Domain

本アプリの品質を支える「守るべき前提条件・壊れてはならない状態」の定義。

ユースケース単位のロジックよりも長寿命であり、  
データの整合性と API の一貫性を保証する。

---

# 1. モデル不変条件（Model-Level Invariants）

## (1) Note は必ず Book に属する
- note.book_id は null ではない
- 存在しない book_id を参照しない（FK 制約）

**Why**: 整理の単位が Book であるため、孤児 Note を生まない。

---

## (2) quote は必須である
- 空文字や nil は許容しない

**Why**:  
引用が空なら Note の存在理由がない。  
UI/UX とも整合が取れない。

---

## (3) page は「null または 1以上」
- null: ページ情報が不明な引用（許容）
- 数値がある場合は必ず `>= 1`

**Why**: 読書中にページが分からないケースは自然にある。  
不正なページ番号（0, negative）で DB を汚さない。

---

## (4) Note の内容はアトミックに保存される
- 途中で半分だけ更新される状態は存在しない

**Why**:  
部分更新が発生すると「引用メモ」という単位が破壊される。

---

---

# 2. API 不変条件（API-Level Invariants）

Bulk Create Notes を前提とした API の保証。

---

## (1) 1リクエスト = 1トランザクション
- Service Layer 内で ActiveRecord::Base.transaction を使用
- トランザクション境界は「notes の insert だけ」を対象とする

**Why**:  
atomicity（不可分性）を保証するため。

---

## (2) 全件成功 or 全件失敗（all-or-nothing）
- 1件でも invalid が発生したらロールバック
- DB 上に“中途半端な保存”は絶対に残らない

**Why**:  
UX（まとめて入力 → まとめて保存）が破壊されるため。  
実務でも最も重要な不変条件。

---

## (3) エラーは「どの要素で失敗したか」を返す
例：

```json
errors: [
{ index: 0, messages: [“page must be greater than 0”] },
{ index: 2, messages: [“quote can’t be blank”] }
]
```


**Why**:  
部分成功を禁止した上で、ユーザーが修正しやすい形でエラーを返す必要がある。

---

## (4) 副作用が二重発生しない（idempotency 準対応）
- 同じリクエストを2度送っても「クラッシュしない」
- 完全な idempotency は今回のMVP範囲外

**Why**:  
保存ボタン連打などの現実的ケースに耐える最低限の要件。

---

---

# 3. 検索（SearchNotes）の不変条件

## (1) Book に属する Note だけを検索対象とする
- `WHERE notes.book_id = ?` は常に適用

## (2) ページ範囲検索は「閉区間」
例：page_from=10, page_to=20  
→ 10–20 の Note 全件

## (3) 検索結果は必ず created_at DESC で安定ソート

**Why**:  
ユーザーは読書の“新→旧”順で確認するため。

---

# 4. 今後の拡張を阻害しないための不変条件

以下は将来のタグ機能・章構造化機能を見据えた長期不変条件。

## (1) Note の意味は「引用の1単位」から変えない  
→ タグ・章などのメタ情報は外部テーブルで扱う。

## (2) Book は Note の最小グループ単位のまま  
→ multi-user / collaborative 化してもこの境界を壊さない。

## (3) モデルにビジネスロジックを詰め込みすぎない  
→ 主要な振る舞いは Service Layer に置く。

---

# 結論

この不変条件セットは以下を保証する：

- モデル整合性が常に保たれる  
- Bulk Create のトランザクション境界が一貫する  
- 検索結果が安定し、UI/UX が崩れない  
- MVP から将来の拡張まで壊れない設計基盤になる